/* Copyright 2012 The ChromiumOS Authors
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 *
 * Functions for querying, manipulating and locking secure data spaces
 * stored in the TPM NVRAM (mock versions).
 */

#include <tss_constants.h>
#include <vb2_api.h>

#include "base/timestamp.h"
#include "secdata_tpm.h"

int secdata_kernel_locked = 0;

uint32_t secdata_firmware_write(struct vb2_context *ctx)
{
	ctx->flags &= ~VB2_CONTEXT_SECDATA_FIRMWARE_CHANGED;
	return TPM_SUCCESS;
}

uint32_t secdata_kernel_write(struct vb2_context *ctx)
{
	ctx->flags &= ~VB2_CONTEXT_SECDATA_KERNEL_CHANGED;
	return TPM_SUCCESS;
}

uint32_t secdata_kernel_lock(struct vb2_context *ctx)
{
	secdata_kernel_locked = 1;
	return TPM_SUCCESS;
}

uint32_t secdata_fwmp_read(struct vb2_context *ctx)
{
	ctx->flags |= VB2_CONTEXT_NO_SECDATA_FWMP;
	return TPM_SUCCESS;
}

uint32_t secdata_widevine_prepare(struct vb2_context *ctx)
{
	return TPM_SUCCESS;
}

uint32_t secdata_extend_kernel_pcr(struct vb2_context *ctx)
{
	return TPM_SUCCESS;
}

#define DESKTOP_TRUSTY "desktop-trusty"
#define ENTROPY_COMPAT "google,early-entropy"
#define SESSION_COMPAT "google,session-key-seed"
#define AUTH_TOKEN_COMPAT "google,auth-token-key-seed"
#define VERSIONED_SEED_COMPAT "google,versioned-seed"

/**
 * Mocked pvmfw BootParam v2 CBOR payload. Provided by @apronin.
 */
static const struct __packed {
	uint8_t map_label;

	struct __packed {
		uint8_t key;
		uint8_t version;
	} version;

	struct __packed {
		uint8_t key;
		uint8_t bstr16_label;
		uint16_t size;

		struct __packed handover_cbor {
			uint8_t map_label;
			struct __packed {
				uint8_t key;
				uint8_t bstr8_label;
				uint8_t size;
				uint8_t cdi[32];
			} cdi_attest;
			struct __packed {
				uint8_t key;
				uint8_t bstr8_label;
				uint8_t size;
				uint8_t cdi[32];
			} cdi_seal;
			struct __packed {
				uint8_t key;
				uint8_t chain[639];
			} cert_chain;
		} handover;
	} dice_handover;

	struct __packed {
		uint8_t key;
		uint8_t bstr16_label;
		uint16_t size;

		uint32_t rmem_count;
		struct __packed {
			uint32_t vm_name_offset;
			uint32_t blob_offset;
			uint32_t blob_size;
			uint32_t compat_offset;
			uint32_t flags;
		} hdrs[4];

		struct __packed rmem_blobs {
			uint8_t early_entropy[64];
			uint8_t session_key_seed[32];
			uint8_t auth_token_seed[32];
			struct __packed {
				uint8_t key_seed[32];
				uint32_t version;
			} versioned_seed;

			uint8_t desktop_trusty[sizeof(DESKTOP_TRUSTY)];
			uint8_t entropy_compat[sizeof(ENTROPY_COMPAT)];
			uint8_t session_compat[sizeof(SESSION_COMPAT)];
			uint8_t auth_compat[sizeof(AUTH_TOKEN_COMPAT)];
			uint8_t versioned_compat[sizeof(VERSIONED_SEED_COMPAT)];
		} blob;
	} rmem;

} mocked_pvmfw_params = {
	.map_label = 0xa3,
	.version = {
		.key = 1,
		.version = 1,
	},
	.dice_handover = {
		.key = 4,
		.bstr16_label = 0x59,
		.size = htobe16(sizeof(struct handover_cbor)),
		.handover = {
			.map_label = 0xa3,
			.cdi_attest = {
				.key = 1,
				.bstr8_label = 0x58,
				.size = 32,
				.cdi = {
					0xe0, 0x45, 0xa8, 0x87, 0xf8, 0x5a, 0xb8, 0xd6,
					0xcf, 0x14, 0x4c, 0xc3, 0xa3, 0x64, 0xf4, 0x5d,
					0xd4, 0xc2, 0x10, 0x14, 0x3f, 0xf3, 0xd9, 0x31,
					0x60, 0xc9, 0x6f, 0x5f, 0xb9, 0x58, 0xde, 0xa5,
				},
			},
			.cdi_seal = {
				.key = 2,
				.bstr8_label = 0x58,
				.size = 32,
				.cdi = {
					0x05, 0x64, 0x9d, 0xf6, 0x35, 0xc8, 0xca, 0x18,
					0x57, 0x11, 0xbe, 0x0c, 0xa2, 0x6b, 0x22, 0x6e,
					0x60, 0x2d, 0xab, 0x4e, 0x7a, 0x51, 0xab, 0xf0,
					0x5c, 0x98, 0x49, 0xea, 0xaa, 0x31, 0x0e, 0x09,
				},
			},
			.cert_chain = {
				.key = 3,
				.chain = {
					0x82, 0xa6, 0x01, 0x02, 0x03, 0x26, 0x04, 0x81,
					0x02, 0x20, 0x01, 0x21, 0x58, 0x20, 0xdd, 0xd6,
					0x89, 0xfe, 0xf9, 0x6c, 0x34, 0xf1, 0x34, 0x74,
					0x7e, 0x2c, 0x4d, 0x4f, 0xd8, 0xca, 0x9c, 0xdf,
					0xee, 0x68, 0x28, 0xf5, 0xd1, 0xe6, 0x31, 0xde,
					0x79, 0x1c, 0xeb, 0x0e, 0xb1, 0x52, 0x22, 0x58,
					0x20, 0xe2, 0xe2, 0x39, 0x67, 0x11, 0x6a, 0xa1,
					0x6d, 0x35, 0x3a, 0xa3, 0xed, 0x8b, 0x23, 0x9c,
					0xe8, 0xde, 0xa1, 0xd9, 0x13, 0x76, 0x2a, 0xe4,
					0x45, 0x87, 0x90, 0x3f, 0x28, 0xf4, 0x86, 0x30,
					0xb0, 0x84, 0x43, 0xa1, 0x01, 0x26, 0xa0, 0x59,
					0x01, 0xe3, 0xaa, 0x01, 0x78, 0x28, 0x65, 0x35,
					0x64, 0x37, 0x62, 0x36, 0x39, 0x33, 0x36, 0x35,
					0x65, 0x61, 0x61, 0x33, 0x61, 0x65, 0x34, 0x37,
					0x63, 0x61, 0x35, 0x36, 0x62, 0x63, 0x61, 0x34,
					0x30, 0x34, 0x34, 0x62, 0x39, 0x31, 0x61, 0x34,
					0x31, 0x64, 0x66, 0x33, 0x36, 0x35, 0x02, 0x78,
					0x28, 0x34, 0x34, 0x38, 0x61, 0x30, 0x35, 0x61,
					0x36, 0x66, 0x66, 0x38, 0x38, 0x31, 0x35, 0x63,
					0x32, 0x65, 0x64, 0x61, 0x61, 0x65, 0x33, 0x39,
					0x38, 0x32, 0x65, 0x61, 0x37, 0x64, 0x36, 0x33,
					0x33, 0x35, 0x36, 0x32, 0x37, 0x34, 0x39, 0x36,
					0x34, 0x3a, 0x00, 0x47, 0x44, 0x50, 0x58, 0x20,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x3a, 0x00, 0x47, 0x44, 0x52, 0x58, 0x20, 0x7b,
					0xbb, 0x59, 0x1a, 0x1f, 0xf3, 0x24, 0x20, 0xda,
					0xe2, 0xf2, 0x61, 0x16, 0xd1, 0xee, 0x12, 0x08,
					0x63, 0xc4, 0xb7, 0x05, 0x6d, 0x3f, 0xad, 0x92,
					0xd3, 0xa5, 0xa8, 0xbd, 0x23, 0xb8, 0xee, 0x3a,
					0x00, 0x47, 0x44, 0x53, 0x58, 0x9b, 0xaa, 0x3a,
					0x00, 0x01, 0x11, 0x71, 0x6a, 0x43, 0x72, 0x4f,
					0x53, 0x20, 0x41, 0x50, 0x20, 0x46, 0x57, 0x3a,
					0x00, 0x01, 0x11, 0x73, 0xf6, 0x3a, 0x00, 0x01,
					0x11, 0x74, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x3a,
					0x00, 0x01, 0x15, 0x57, 0x1a, 0x00, 0x00, 0x00,
					0x21, 0x3a, 0x00, 0x01, 0x15, 0x58, 0x58, 0x20,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x3a, 0x00, 0x01, 0x15, 0x59, 0x58, 0x20, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a,
					0x00, 0x01, 0x15, 0x5a, 0x18, 0x00, 0x3a, 0x00,
					0x01, 0x15, 0x5b, 0x18, 0x00, 0x3a, 0x00, 0x01,
					0x15, 0x5c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x3a,
					0x00, 0x01, 0x15, 0x5d, 0x1a, 0x00, 0x00, 0x00,
					0x00, 0x3a, 0x00, 0x47, 0x44, 0x54, 0x58, 0x20,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x3a, 0x00, 0x47, 0x44, 0x56, 0x41, 0x02, 0x3a,
					0x00, 0x47, 0x44, 0x57, 0x58, 0x50, 0xa6, 0x01,
					0x02, 0x03, 0x26, 0x04, 0x81, 0x02, 0x20, 0x01,
					0x21, 0x58, 0x20, 0xbc, 0x1c, 0x4f, 0x09, 0xb5,
					0xe2, 0x0a, 0xc3, 0xc1, 0xfe, 0xc5, 0x45, 0x6b,
					0x63, 0x08, 0xfa, 0x8f, 0x60, 0x86, 0x1d, 0x8c,
					0x9a, 0x80, 0x5a, 0x2f, 0x4b, 0xd8, 0xf3, 0x33,
					0x6a, 0x9a, 0x2a, 0x22, 0x58, 0x20, 0x51, 0xec,
					0x99, 0x6e, 0x1f, 0xe1, 0x5e, 0x78, 0xdc, 0x3c,
					0x1a, 0x85, 0x43, 0x09, 0xd1, 0xc6, 0x2a, 0x24,
					0x9c, 0xc4, 0x29, 0x01, 0xe4, 0x47, 0x2d, 0x19,
					0x5d, 0xf9, 0xd8, 0x65, 0xb3, 0xf3, 0x3a, 0x00,
					0x47, 0x44, 0x58, 0x41, 0x20, 0x3a, 0x00, 0x47,
					0x44, 0x59, 0x6a, 0x61, 0x6e, 0x64, 0x72, 0x6f,
					0x69, 0x64, 0x2e, 0x31, 0x36, 0x58, 0x40, 0xc9,
					0x4f, 0x49, 0x33, 0x61, 0xdd, 0x66, 0x45, 0x99,
					0x56, 0xc6, 0xfd, 0x92, 0xa8, 0x8b, 0x73, 0x9f,
					0x5c, 0x3e, 0x79, 0xca, 0x97, 0xc2, 0x13, 0x20,
					0x58, 0xec, 0xd5, 0xe9, 0xcf, 0x11, 0xe7, 0x5f,
					0xfa, 0x53, 0xa0, 0xc1, 0x9d, 0x08, 0x92, 0x09,
					0xcf, 0x7c, 0x79, 0x1e, 0x74, 0xa0, 0x1e, 0xac,
					0x31, 0x6f, 0x70, 0x76, 0x38, 0xe8, 0xde, 0xa3,
					0x33, 0x7c, 0x6c, 0xd9, 0x5c, 0x03, 0x48,
				},
			},
		},
	},
	.rmem = {
		.key = 5,
		.bstr16_label = 0x59,
		.size = htobe16(0x0165),

		.rmem_count = 4,
		.hdrs[0] = {
			.vm_name_offset = htole32(offsetof(struct rmem_blobs, desktop_trusty)),
			.blob_offset = htole32(offsetof(struct rmem_blobs, early_entropy)),
			.blob_size = htole32(64),
			.compat_offset = htole32(offsetof(struct rmem_blobs, entropy_compat)),
			.flags = htole32(0x01),
		},
		.hdrs[1] = {
			.vm_name_offset = htole32(offsetof(struct rmem_blobs, desktop_trusty)),
			.blob_offset = htole32(offsetof(struct rmem_blobs, session_key_seed)),
			.blob_size = htole32(32),
			.compat_offset = htole32(offsetof(struct rmem_blobs, session_compat)),
			.flags = htole32(0x01),
		},
		.hdrs[2] = {
			.vm_name_offset = htole32(offsetof(struct rmem_blobs, desktop_trusty)),
			.blob_offset = htole32(offsetof(struct rmem_blobs, auth_token_seed)),
			.blob_size = htole32(32),
			.compat_offset = htole32(offsetof(struct rmem_blobs, auth_compat)),
			.flags = htole32(0x01),
		},
		.hdrs[3] = {
			.vm_name_offset = htole32(offsetof(struct rmem_blobs, desktop_trusty)),
			.blob_offset = htole32(offsetof(struct rmem_blobs, versioned_seed)),
			.blob_size = htole32(32 + 4),
			.compat_offset = htole32(offsetof(struct rmem_blobs, versioned_compat)),
			.flags = htole32(0x01),
		},

		.blob = {
			.early_entropy = {
				0xa7, 0x15, 0x08, 0xa1, 0x98, 0x07, 0x12, 0xed,
				0xd0, 0x6b, 0x88, 0x75, 0xd8, 0x88, 0x81, 0xac,
				0x7a, 0xe9, 0x36, 0x44, 0x9d, 0xad, 0xf8, 0x8e,
				0x40, 0xcc, 0xb1, 0x08, 0xb4, 0x2b, 0x74, 0x70,
				0x5c, 0x24, 0xe9, 0x4a, 0xa1, 0x47, 0xff, 0x82,
				0x94, 0x4a, 0xf0, 0x68, 0xa9, 0xda, 0x41, 0xec,
				0xd4, 0x50, 0x71, 0xb3, 0xa8, 0xc6, 0x90, 0xbf,
				0xac, 0x8e, 0x14, 0x0b, 0xf6, 0x13, 0x39, 0x4f,
			},
			.session_key_seed = {
				0x09, 0xaa, 0x5f, 0x0b, 0x23, 0x8d, 0x9b, 0x04,
				0x6c, 0x28, 0x6e, 0x96, 0xca, 0x8e, 0x97, 0xed,
				0x60, 0xdd, 0x08, 0x91, 0xa5, 0x83, 0xea, 0x32,
				0x32, 0x78, 0xbe, 0x89, 0x59, 0x70, 0x47, 0xd7,
			},
			.auth_token_seed = {
				0x15, 0xc0, 0x31, 0x2c, 0x45, 0x85, 0x6a, 0x87,
				0x40, 0x74, 0x65, 0x48, 0x44, 0x1e, 0x48, 0x4c,
				0x2c, 0xcc, 0xc5, 0x23, 0xfa, 0x31, 0xa9, 0x6a,
				0x04, 0xbf, 0x81, 0xbd, 0x85, 0x31, 0x14, 0x62,
			},
			.versioned_seed = {
				.key_seed = {
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				.version = 0,
			},
			.desktop_trusty = DESKTOP_TRUSTY,
			.entropy_compat = ENTROPY_COMPAT,
			.session_compat = SESSION_COMPAT,
			.auth_compat = AUTH_TOKEN_COMPAT,
			.versioned_compat = VERSIONED_SEED_COMPAT,
		},
	},
};

uint32_t secdata_get_pvmfw_params(void **boot_params, size_t *params_size)
{
	void *params;

	*params_size = sizeof(mocked_pvmfw_params);

	/* Allocate a buffer for BootParam CBOR object */
	params = malloc(*params_size);
	if (!params) {
		printf("Failed to allocate buffer for pvmfw params\n");
		return TPM_E_RESPONSE_TOO_LARGE;
	}

	/* Copy mocked BootParam CBOR */
	memcpy(params, &mocked_pvmfw_params, *params_size);

	*boot_params = params;

	return TPM_SUCCESS;
}

uint32_t secdata_generate_randomness(uint8_t *seed, size_t size)
{
	memset(seed, 0x42, size);
	timestamp_mix_in_randomness(seed, size);
	return TPM_SUCCESS;
}
